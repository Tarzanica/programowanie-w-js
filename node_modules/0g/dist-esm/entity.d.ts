import { Poolable } from './internal/objectPool';
import { Query } from './queries';
import { Store, StoreInstance, StoreInstanceFor } from './stores';
import { Game } from './Game';
export declare class Entity implements Poolable {
    __data: Map<Store, StoreInstance>;
    __queries: Set<Query<any>>;
    __game: Game;
    __stores: Store[];
    __alive: boolean;
    id: string;
    init(id: string, specs: Store[]): void;
    /**
     * Gets a Store instance of the provided type from the entity,
     * throwing if that store does not exist. The returned value is
     * readonly! Use the .set method to modify properties, or use
     * .getWritable instead if you want to assign directly. Use
     * .maybeGet if you're ok with a null value instead of throwing
     * for nonexistent stores.
     */
    get<Spec extends Store>(spec: Spec): Readonly<StoreInstanceFor<Spec>>;
    maybeGet<Spec extends Store>(spec: Spec): Readonly<StoreInstanceFor<Spec>> | null;
    /**
     * Gets a Store of the given type from the entity which is
     * directly writable. If this getter is used, it is assumed that
     * the store will be modified, and any watchers will be updated next frame.
     * This getter throws if the store is not present. Use .maybeGetWritable
     * instead if you would rather get a null value.
     */
    getWritable<Spec extends Store>(spec: Spec): StoreInstanceFor<Spec>;
    maybeGetWritable<Spec extends Store>(spec: Spec): StoreInstanceFor<Spec> | null;
    private getOrNull;
    add<Spec extends Store>(spec: Spec, initial?: Partial<StoreInstanceFor<Spec>>): this;
    remove(spec: Store): this;
    reset(): void;
    get specs(): {
        queries: string[];
        stores: string[];
    };
}
