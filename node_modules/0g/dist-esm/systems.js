var FrameHandle = /** @class */ (function () {
    function FrameHandle(handle, game) {
        this.handle = handle;
        this.game = game;
        this.attach();
    }
    FrameHandle.prototype.attach = function () {
        this.game.on('step', this.handle);
    };
    FrameHandle.prototype.detach = function () {
        this.game.off('step', this.handle);
    };
    return FrameHandle;
}());
export { FrameHandle };
var System = /** @class */ (function () {
    function System(game) {
        this.game = game;
    }
    System.prototype.query = function (queryDef) {
        return this.game.queries.create(queryDef);
    };
    System.prototype.frame = function (query, run) {
        return new FrameHandle(function () {
            query.entities.forEach(run);
        }, this.game);
    };
    System.prototype.watch = function (query, stores, run) {
        return new FrameHandle(function () {
            // TODO: consider implications of object pooling on weakmap usage - it
            // probably makes them irrelevant, but possibly also incorrect?
            var versionCache = new WeakMap();
            // TODO: optimize this use case within Query
            query.entities.forEach(function (entity) {
                var currentVersions = stores
                    .map(function (s) { return entity.get(s).__version; })
                    .join(',');
                if (currentVersions !== versionCache.get(entity)) {
                    versionCache.set(entity, currentVersions);
                    run(entity);
                }
            });
        }, this.game);
    };
    return System;
}());
export { System };
//# sourceMappingURL=systems.js.map