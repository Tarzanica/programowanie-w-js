/// <reference types="node" />
import { EventEmitter } from 'events';
import * as input from './input';
import { EntityManager } from './entityManager';
import { QueryManager } from './queryManager';
import { Store } from './stores';
import { StoreManager } from './storeManager';
import { SystemSpec } from './systems';
export declare type GamePlayState = 'paused' | 'running';
export declare interface Game {
    on(event: 'step', callback: () => void): this;
    on(event: 'playStateChanged', callback: (state: GamePlayState) => void): this;
}
export declare class Game extends EventEmitter {
    private _entityManager;
    private _stores;
    private _systems;
    private _systemInstances;
    private _queryManager;
    private _storeManager;
    private _raf;
    private _cancelRaf;
    _playState: GamePlayState;
    private _lastFrameTime;
    private _delta;
    private _time;
    private _frameHandle;
    constructor({ stores, requestFrame, cancelFrame, initialPlayState: initialState, systems, }: {
        stores: Record<string, Store>;
        requestFrame?: (callback: FrameRequestCallback) => number;
        cancelFrame?: (frameHandle: number) => void;
        initialPlayState?: GamePlayState;
        systems?: SystemSpec[];
    });
    get entities(): EntityManager;
    get storeSpecs(): Record<string, Store>;
    get playState(): GamePlayState;
    get isPaused(): boolean;
    get delta(): number;
    get time(): number;
    get queries(): QueryManager;
    get stores(): StoreManager;
    get: (id: string) => import("./entity").Entity;
    create: (ownId?: string | null) => import("./entity").Entity;
    destroy: (id: string) => void;
    resume: () => void;
    pause: () => void;
    loadScene: (serialized: {
        id: string;
        data: Record<string, any>;
    }[]) => void;
    saveScene: () => ({
        id: string;
        data: Record<string, any>;
    } | undefined)[];
    input: typeof input;
    private runFrame;
}
