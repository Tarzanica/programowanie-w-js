var Entity = /** @class */ (function () {
    function Entity() {
        this.__data = new Map();
        this.__queries = new Set();
        this.__game = null;
        this.__stores = [];
        this.__alive = true;
        this.id = 'unallocated';
    }
    Entity.prototype.init = function (id, specs) {
        var _this = this;
        this.__stores = specs;
        this.id = id;
        specs.forEach(function (spec) {
            _this.add(spec);
        });
    };
    /**
     * Gets a Store instance of the provided type from the entity,
     * throwing if that store does not exist. The returned value is
     * readonly! Use the .set method to modify properties, or use
     * .getWritable instead if you want to assign directly. Use
     * .maybeGet if you're ok with a null value instead of throwing
     * for nonexistent stores.
     */
    Entity.prototype.get = function (spec) {
        var val = this.maybeGet(spec);
        if (!val) {
            throw new Error(spec.name + " not present on entity " + this.id);
        }
        return val;
    };
    Entity.prototype.maybeGet = function (spec) {
        var val = this.getOrNull(spec);
        if (!val)
            return null;
        return val;
    };
    /**
     * Gets a Store of the given type from the entity which is
     * directly writable. If this getter is used, it is assumed that
     * the store will be modified, and any watchers will be updated next frame.
     * This getter throws if the store is not present. Use .maybeGetWritable
     * instead if you would rather get a null value.
     */
    Entity.prototype.getWritable = function (spec) {
        var val = this.maybeGetWritable(spec);
        if (!val) {
            throw new Error(spec.name + " not present on entity " + this.id);
        }
        return val;
    };
    Entity.prototype.maybeGetWritable = function (spec) {
        var val = this.getOrNull(spec);
        if (!val)
            return null;
        // mark the store preemptively as written to
        val.mark();
        return val;
    };
    Entity.prototype.getOrNull = function (spec) {
        var val = this.__data.get(spec);
        return val || null;
    };
    Entity.prototype.add = function (spec, initial) {
        this.__game.entities.addStoreToEntity(this, spec, initial);
        this.__stores.push(spec);
        return this;
    };
    Entity.prototype.remove = function (spec) {
        this.__game.entities.removeStoreFromEntity(this, spec);
        return this;
    };
    Entity.prototype.reset = function () {
        var _this = this;
        this.__data.forEach(function (data, spec) {
            _this.__game.stores.release(data);
        });
        this.__data.clear();
        this.__stores = [];
        this.__queries = new Set();
    };
    Object.defineProperty(Entity.prototype, "specs", {
        get: function () {
            return {
                queries: Array.from(this.__queries.values()).map(function (q) { return q.key; }),
                stores: this.__stores.map(function (spec) { return spec.name; }),
            };
        },
        enumerable: false,
        configurable: true
    });
    return Entity;
}());
export { Entity };
//# sourceMappingURL=entity.js.map